        OCaml version 4.02.3

let l = [['a';'b'];['a'];['a';'c'];['d';'e'];['a';'b']];;
# val l : char list list =
  [['a'; 'b']; ['a']; ['a'; 'c']; ['d'; 'e']; ['a'; 'b']]
# l;;
- : char list list = [['a'; 'b']; ['a']; ['a'; 'c']; ['d'; 'e']; ['a'; 'b']]
# let kst = 1::2::3::1::2::[];;
val kst : int list = [1; 2; 3; 1; 2]
# let rec nbrStates liste = match liste with
  |[] -> 0
  |elt::listeQueue -> 1 + (nbrStates listeQueue);;
    val nbrStates : 'a list -> int = <fun>
# nbrStates l;;
- : int = 5
# let rec estPresent x liste = match liste with
  |[] -> false
  |elt::[] -> if (elt = x) then true
             else false
  |elt::listeQueue -> if (elt = x) then true
                                          else estPresent x listeQueue;;
          val estPresent : 'a -> 'a list -> bool = <fun>
# let rec suppDoublons liste = match liste with
  |[] -> []
  |elt::[] -> liste
  |elt::listeQueue -> if (estPresent elt listeQueue = true) then suppDoublons listeQueue
                      else elt::suppDoublons listeQueue;;
        val suppDoublons : 'a list -> 'a list = <fun>
# suppDoublons kst;;
- : int list = [3; 1; 2]
# let ajouterElt elt liste = match liste with
  |[] -> [elt]
  |e::listeQueue -> if (estPresent elt liste = true) then liste
                    else elt::liste;;
      val ajouterElt : 'a -> 'a list -> 'a list = <fun>
# ajouterElt [2;1] [[1];[1;2];[0]];;
- : int list list = [[2; 1]; [1]; [1; 2]; [0]]
# let rec comparerStates l1 l2 =
  if (nbrStates l1 = nbrStates l2)
  then match l1, l2 with
       |[], [] -> true
       |[], _ -> true
       |_, [] -> false
       |e1::l1Queue, _ -> if (estPresent e1 l2 = true) then comparerStates l1Queue l2
                          else false
  else false;;
                val comparerStates : 'a list -> 'a list -> bool = <fun>
# comparerStates [3;2;4;0;6] [6;0;3;5;2];;
- : bool = false
# let rec suppDoublonsDansState listeListes = match listeListes with
                                       |[] -> []
                                       |state::listeListesQueue -> suppDoublonsDansState (suppDoublons state);;
    Characters 205-225:
                                         |state::listeListesQueue -> suppDoublonsDansState (suppDoublons state);;
                                                                                           ^^^^^^^^^^^^^^^^^^^^
Error: This expression has type 'a list
       but an expression was expected of type 'a list list
# let construireKST listeListes = if (nbrStates liste < 2) then failwith "La Knowledge Structure doit contenir au moins deux States (l'ensemble vide et le domaine)!"
                                else let listeListes2 = fun 
                                     in ajouterElt [] listeListes2;;
    Characters 262-264:
                                       in ajouterElt [] listeListes2;;
                                       ^^
Error: Syntax error
# construireKST [[2];[3];[1];[2;2];[3]];;
Characters 0-13:
  construireKST [[2];[3];[1];[2;2];[3]];;
  ^^^^^^^^^^^^^
Error: Unbound value construireKST
# let construireKST listeListes = if (nbrStates liste < 2) then failwith "La Knowledge Structure doit contenir au moins deux States (l'ensemble vide et le domaine)!"
                                else let listeListes2 = List.map suppDoublons listeListes
                                     in ajouterElt [] listeListes2;;
    Characters 46-51:
  let construireKST listeListes = if (nbrStates liste < 2) then failwith "La Knowledge Structure doit contenir au moins deux States (l'ensemble vide et le domaine)!"
                                                ^^^^^
Error: Unbound value liste
# let construireKST listeListes = if (nbrStates listeListes < 2) then failwith "La Knowledge Structure doit contenir au moins deux States (l'ensemble vide et le domaine)!"
                                else let listeListes2 = List.map suppDoublons listeListes
                                     in ajouterElt [] listeListes2;;
    val construireKST : 'a list list -> 'a list list = <fun>
# construireKST [[2];[3];[1];[2;2];[3]];;
- : int list list = [[]; [2]; [3]; [1]; [2]; [3]]
# construireKST [[2];[3];[1;1];[2;2];[3;3;3]];;
- : int list list = [[]; [2]; [3]; [1]; [2]; [3]]
# let rec suppStatesDoublons listeListes = match listeListes with
  |[] -> []
  |state::[] -> listeListes
  |state1::state2::listeListesQueue -> if (comparerState state1 state2 = true) then suppStatesDoublons state2::listeListesQueue
                      else state1::suppStatesDoublons state2::listeListesQueue;;
        Characters 147-160:
    |state1::state2::listeListesQueue -> if (comparerState state1 state2 = true) then suppStatesDoublons state2::listeListesQueue
                                             ^^^^^^^^^^^^^
Error: Unbound value comparerState
Hint: Did you mean comparerStates?
# let rec comparerStates l1 l2 =
  if (nbrStates l1 = nbrStates l2)
  then match l1, l2 with
       |[], [] -> true
       |[], _ -> true
       |_, [] -> false
       |e1::l1Queue, _ -> if (estPresent e1 l2 = true) then comparerStates l1Queue l2
                          else false
  else false;;
                val comparerStates : 'a list -> 'a list -> bool = <fun>
# let rec suppStatesDoublons listeListes = match listeListes with
  |[] -> []
  |state::[] -> listeListes
  |state1::state2::listeListesQueue -> if (comparerStates state1 state2 = true) then suppStatesDoublons state2::listeListesQueue
                      else state1::suppStatesDoublons state2::listeListesQueue;;
        Characters 208-214:
    |state1::state2::listeListesQueue -> if (comparerStates state1 state2 = true) then suppStatesDoublons state2::listeListesQueue
                                                                                                          ^^^^^^
Error: This expression has type 'a list
       but an expression was expected of type 'a list list
# let rec suppStatesDoublons listeListes = match listeListes with
  |[] -> []
  |[state] -> listeListes
  |state1::state2::listeListesQueue -> if (comparerStates state1 state2 = true) then suppStatesDoublons [state2::listeListesQueue
                      else state1::suppStatesDoublons state2::listeListesQueue;;
        Characters 208-214:
    |state1::state2::listeListesQueue -> if (comparerStates state1 state2 = true) then suppStatesDoublons state2::listeListesQueue
                                                                                                          ^^^^^^
Error: This expression has type 'a list
       but an expression was expected of type 'a list list
# let rec suppStatesDoublons listeListes = match listeListes with
  |[] -> []
  |[[state]] -> listeListes
  |state1::state2::listeListesQueue -> if (comparerStates state1 state2 = true) then suppStatesDoublons [state2]::listeListesQueue
                      else state1::suppStatesDoublons state2::listeListesQueue;;
        Characters 189-216:
    |state1::state2::listeListesQueue -> if (comparerStates state1 state2 = true) then suppStatesDoublons [state2]::listeListesQueue
                                                                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^
Error: This expression has type 'a list list
       but an expression was expected of type 'a list
       The type variable 'a occurs inside 'a list
# let rec suppStatesDoublons listeListes = match listeListes with
  |[] -> []
  |[[state]] -> listeListes
  |[state1]::[state2]::[listeListesQueue] -> if (comparerStates state1 state2 = true) then suppStatesDoublons [state2]::listeListesQueue
                      else state1::suppStatesDoublons state2::listeListesQueue;;
        Characters 215-221:
    |[state1]::[state2]::[listeListesQueue] -> if (comparerStates state1 state2 = true) then suppStatesDoublons [state2]::listeListesQueue
                                                                                                                 ^^^^^^
Error: This expression has type 'a list
       but an expression was expected of type 'a list list
# let rec suppStatesDoublons listeListes = match listeListes with
  |[] -> []
  |[[state]] -> listeListes
  |[state1]::[state2]::[listeListesQueue] -> if (comparerStates state1 state2 = true) then suppStatesDoublons [state2]::[listeListesQueue]
                      else state1::suppStatesDoublons state2::listeListesQueue;;
        Characters 215-221:
    |[state1]::[state2]::[listeListesQueue] -> if (comparerStates state1 state2 = true) then suppStatesDoublons [state2]::[listeListesQueue]
                                                                                                                 ^^^^^^
Error: This expression has type 'a list
       but an expression was expected of type 'a list list
# let rec suppStatesDoublons listeListes = match listeListes with
  |[] -> []
  |[[state]] -> listeListes
  |[state1]::[state2]::[listeListesQueue] -> if (comparerStates state1 state2 = true) then suppStatesDoublons ([state2]::[listeListesQueue])
                      else state1::suppStatesDoublons state2::listeListesQueue;;
        Characters 272-278:
                        else state1::suppStatesDoublons state2::listeListesQueue;;
                             ^^^^^^
Error: This expression has type 'a list
       but an expression was expected of type 'a list list
# let rec suppStatesDoublons listeListes = match listeListes with
  |[] -> []
  |[[state]] -> listeListes
  |[state1]::[state2]::[listeListesQueue] -> if (comparerStates state1 state2 = true) then suppStatesDoublons ([state2]::[listeListesQueue])
                      else [state1]::suppStatesDoublons ([state2]::[listeListesQueue]);;
        Characters 41-331:
  .........................................match listeListes with
    |[] -> []
    |[[state]] -> listeListes
    |[state1]::[state2]::[listeListesQueue] -> if (comparerStates state1 state2 = true) then suppStatesDoublons ([state2]::[listeListesQueue])
                        else [state1]::suppStatesDoublons ([state2]::[listeListesQueue])..
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
[]::_
val suppStatesDoublons : 'a list list list -> 'a list list list = <fun>
# let rec suppStatesDoublons listeListes = match listeListes with
  |[] -> []
  |[[state]] -> listeListes
  |[state1]::[state2]::listeListesQueue -> if (comparerStates state1 state2 = true) then suppStatesDoublons ([state2]::listeListesQueue)
                      else [state1]::suppStatesDoublons ([state2]::listeListesQueue);;
        Characters 41-325:
  .........................................match listeListes with
    |[] -> []
    |[[state]] -> listeListes
    |[state1]::[state2]::listeListesQueue -> if (comparerStates state1 state2 = true) then suppStatesDoublons ([state2]::listeListesQueue)
                        else [state1]::suppStatesDoublons ([state2]::listeListesQueue)..
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
[]::_
val suppStatesDoublons : 'a list list list -> 'a list list list = <fun>
# let rec suppStatesDoublons listeListes = match listeListes with
  |[] -> []
  |[]::_ -> []
  |[[state]] -> listeListes
  |[state1]::[state2]::listeListesQueue -> if (comparerStates state1 state2 = true) then suppStatesDoublons ([state2]::listeListesQueue)
                      else [state1]::suppStatesDoublons ([state2]::listeListesQueue);;
          Characters 41-340:
  .........................................match listeListes with
    |[] -> []
    |[]::_ -> []
    |[[state]] -> listeListes
    |[state1]::[state2]::listeListesQueue -> if (comparerStates state1 state2 = true) then suppStatesDoublons ([state2]::listeListesQueue)
                        else [state1]::suppStatesDoublons ([state2]::listeListesQueue)..
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
(_::_::_)::_
val suppStatesDoublons : 'a list list list -> 'a list list list = <fun>
# let rec suppStatesDoublons listeListes = match listeListes with
  |[] -> []
  |state1::state2::listeListesQueue -> if (comparerStates state1 state2 = true) then suppStatesDoublons ([state2]::listeListesQueue)
                      else [state1]::suppStatesDoublons ([state2]::listeListesQueue);;
        Characters 208-214:
    |state1::state2::listeListesQueue -> if (comparerStates state1 state2 = true) then suppStatesDoublons ([state2]::listeListesQueue)
                                                                                                            ^^^^^^
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list
# let rec suppStatesDoublons listeListes = match listeListes with
  |[] -> []
  |[state] -> listeListes
  |state1::state2::listeListesQueue -> if (comparerStates state1 state2 = true) then suppStatesDoublons ([state2]::listeListesQueue)
                      else [state1]::suppStatesDoublons ([state2]::listeListesQueue);;
        Characters 208-214:
    |state1::state2::listeListesQueue -> if (comparerStates state1 state2 = true) then suppStatesDoublons ([state2]::listeListesQueue)
                                                                                                            ^^^^^^
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list
# let rec suppStatesDoublons listeListes = match listeListes with
  |[] -> []
  |state1::state2::listeListesQueue -> if (comparerStates state1 state2 = true) then suppStatesDoublons ([state2]::listeListesQueue)
                      else [state1]::suppStatesDoublons ([state2]::listeListesQueue);;
      Characters 182-188:
    |state1::state2::listeListesQueue -> if (comparerStates state1 state2 = true) then suppStatesDoublons ([state2]::listeListesQueue)
                                                                                                            ^^^^^^
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list
# let printListe l = Liste.iter (fun x -> print x ) l;;
Characters 19-29:
  let printListe l = Liste.iter (fun x -> print x ) l;;
                     ^^^^^^^^^^
Error: Unbound module Liste
Hint: Did you mean List?
# let printListe l = List.iter (fun x -> print x ) l;;
Characters 39-44:
  let printListe l = List.iter (fun x -> print x ) l;;
                                         ^^^^^
Error: Unbound value print
# let printListe l = List.iter (fun x -> Print.print x ) l;;
Characters 39-50:
  let printListe l = List.iter (fun x -> Print.print x ) l;;
                                         ^^^^^^^^^^^
Error: Unbound module Print
# let printListe l = List.iter (fun x -> Printf.printf x ) l;;
val printListe : (unit, out_channel, unit) format list -> unit = <fun>
# printListe [1;3;4;2];;
Characters 12-13:
  printListe [1;3;4;2];;
              ^
Error: This expression has type int but an expression was expected of type
         (unit, out_channel, unit) format =
           (unit, out_channel, unit, unit, unit, unit)
           CamlinternalFormatBasics.format6
# let printListe l = List.iter (fun x ->  x+1 ) l;;
Characters 40-43:
  let printListe l = List.iter (fun x ->  x+1 ) l;;
                                          ^^^
Error: This expression has type int but an expression was expected of type
         unit
# let printListe l = List.iter (function x -> x*x ) l;;
Characters 40-45:
  let printListe l = List.iter (fun x ->  x + 1 ) l;;
                                          ^^^^^
Error: This expression has type int but an expression was expected of type
         unit
# let printListe l = List.iter (fun x ->  x + 1 ) l;;
Characters 40-45:
  let printListe l = List.iter (fun x ->  x + 1 ) l;;
                                          ^^^^^
Error: This expression has type int but an expression was expected of type
         unit
# let construireKST listeListes = if (nbrStates listeListes < 2) then failwith "La Knowledge Structure doit contenir au moins deux States (l'ensemble vide et le domaine)!"
                                else let listeListes2 = List.map suppDoublons listeListes
                                     in ajouterElt [] listeListes2;;
    val construireKST : 'a list list -> 'a list list = <fun>
# construireKST [[2];[3];[1;1];[2;2];[3;3;3]];;
- : int list list = [[]; [2]; [3]; [1]; [2]; [3]]
# let rec suppStatesDoublons listeListes = match listeListes with
  |[] -> []
  |[state1]-> listeListes
  |state1::state2::listeListesQueue -> if (comparerStates state1 state2 = true) then suppStatesDoublons (state2::listeListesQueue)
                      else [state1]::suppStatesDoublons ([state2]::listeListesQueue);;
        Characters 208-214:
    |state1::state2::listeListesQueue -> if (comparerStates state1 state2 = true) then suppStatesDoublons ([state2]::listeListesQueue)
                                                                                                            ^^^^^^
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list
# let rec suppStatesDoublons listeListes = match listeListes with
  |[] -> []
  |[state1]-> listeListes
  |state1::state2::listeListesQueue -> if (comparerStates state1 state2 = true) then suppStatesDoublons (state2::listeListesQueue)
                      else [state1]::suppStatesDoublons ([state2]::listeListesQueue);;
        Characters 261-267:
                        else [state1]::suppStatesDoublons ([state2]::listeListesQueue);;
                              ^^^^^^
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list
# let rec suppStatesDoublons listeListes = match listeListes with
  |[] -> []
  |[state1]-> listeListes
  |state1::state2::listeListesQueue -> if (comparerStates state1 state2 = true) then suppStatesDoublons (state2::listeListesQueue)
                      else state1::suppStatesDoublons ([state2]::listeListesQueue);;
        Characters 289-295:
                        else state1::suppStatesDoublons ([state2]::listeListesQueue);;
                                                          ^^^^^^
Error: This expression has type 'a list
       but an expression was expected of type 'a
       The type variable 'a occurs inside 'a list
# let rec suppStatesDoublons listeListes = match listeListes with
  |[] -> []
  |[state1]-> listeListes
  |state1::state2::listeListesQueue -> if (comparerStates state1 state2 = true) then suppStatesDoublons (state2::listeListesQueue)
                      else state1::suppStatesDoublons (state2::listeListesQueue);;
        val suppStatesDoublons : 'a list list -> 'a list list = <fun>
# suppStatesDoublons [[0;4];[5];[4;0]];;
- : int list list = [[0; 4]; [5]; [4; 0]]
# #trace suppDoublonsDansState;;

Unbound value suppDoublonsDansState.
#   #trace suppDoublonsDansState;;
Unbound value suppDoublonsDansState.
# #trace suppStatesDoublons;;
suppStatesDoublons is now traced.
# suppStatesDoublons [[2;4][3][4;2]];;
Characters 20-25:
  suppStatesDoublons [[2;4][3][4;2]];;
                      ^^^^^
Error: This expression has type int list
       This is not a function; it cannot be applied.
# #trace suppStatesDoublons [[2;3];[5];[3;2]];;
Characters 26-27:
  #trace suppStatesDoublons [[2;3];[5];[3;2]];;
                            ^
Error: Syntax error
# #trace suppStatesDoublons;;
suppStatesDoublons is already traced (under the name suppStatesDoublons).
# suppStatesDoublons [[2;3];[4];[3;2]];;
suppStatesDoublons <-- [[<poly>; <poly>]; [<poly>]; [<poly>; <poly>]]
suppStatesDoublons <-- [[<poly>]; [<poly>; <poly>]]
suppStatesDoublons <-- [[<poly>; <poly>]]
suppStatesDoublons --> [[<poly>; <poly>]]
suppStatesDoublons --> [[<poly>]; [<poly>; <poly>]]
suppStatesDoublons --> [[<poly>; <poly>]; [<poly>]; [<poly>; <poly>]]
- : int list list = [[2; 3]; [4]; [3; 2]]
# suppStatesDoublons [[0;4];[4;0]];;
suppStatesDoublons <-- [[<poly>; <poly>]; [<poly>; <poly>]]
suppStatesDoublons <-- [[<poly>; <poly>]]
suppStatesDoublons --> [[<poly>; <poly>]]
suppStatesDoublons --> [[<poly>; <poly>]; [<poly>; <poly>]]
- : int list list = [[0; 4]; [4; 0]]
# let rec suppStatesDoublons listeListes = match listeListes with
  |[] -> []
  |state1::state2::[] -> if (comparerStates state1 state2 = true) then true
                         else false;;
      Characters 147-151:
    |state1::state2::[] -> if (comparerStates state1 state2 = true) then true
                                                                         ^^^^
Error: This variant expression is expected to have type 'a list
       The constructor true does not belong to type list
# let rec suppStatesDoublons listeListes = match listeListes with
  |[] -> false
  |state1::state2::[] -> if (comparerStates state1 state2 = true) then true
                         else false;;
      Characters 41-190:
  .........................................match listeListes with
    |[] -> false
    |state1::state2::[] -> if (comparerStates state1 state2 = true) then true
                           else false..
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
_::[]
val suppStatesDoublons : 'a list list -> bool = <fun>
# suppStatesDoublons [[0;4];[4;0]];;
- : bool = false
# let rec suppStatesDoublons listeListes = match listeListes with
  |[] -> false
  |[state1]::[state2]::[] -> if (comparerStates state1 state2 = true) then true
                         else false;;
      Characters 41-194:
  .........................................match listeListes with
    |[] -> false
    |[state1]::[state2]::[] -> if (comparerStates state1 state2 = true) then true
                           else false..
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
[]::_
val suppStatesDoublons : 'a list list list -> bool = <fun>
# suppStatesDoublons [[0;4];[4;0]];;
Characters 21-22:
  suppStatesDoublons [[0;4];[4;0]];;
                       ^
Error: This expression has type int but an expression was expected of type
         'a list
# let l=[2;3]::[5]::[4]::[];;
val l : int list list = [[2; 3]; [5]; [4]]
# let l=2::3::[]::5::[]::[];;
Characters 12-14:
  let l=2::3::[]::5::[]::[];;
              ^^
Error: This expression has type 'a list
       but an expression was expected of type int
# let present l = match l with
		|[] -> []
		|elt::liste -> elt;; 
    val present : 'a list list -> 'a list = <fun>
# present l ;;
- : int list = [2; 3]
# present [1;2];;
Characters 9-10:
  present [1;2];;
           ^
Error: This expression has type int but an expression was expected of type
         'a list
#  let present l = match l with
		|[] -> []
		|elt::elt2::liste -> elt2;; 
    Characters 17-69:
  .................match l with
  		|[] -> []
  		|elt::elt2::liste -> elt2...
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
_::[]
val present : 'a list list -> 'a list = <fun>
# present [[5];[4;6];[3]];;
- : int list = [4; 6]
# let present l = match l with
  |[] -> []
  |_ :: [] -> _
  |elt::elt2::[] -> elt2;;
	 
      Characters 55-56:
    |_ :: [] -> _
                ^
Error: Syntax error
#   let present l = match l with
  |[] -> []
  |_ :: [] -> []
  |elt::elt2::[] -> elt2;;
      Characters 19-85:
  ................match l with
    |[] -> []
    |_ :: [] -> []
    |elt::elt2::[] -> elt2..
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
_::_::_::_
val present : 'a list list -> 'a list = <fun>
# let present l = match l with
  |[] -> []
  |_ :: [] -> _
  |elt::elt2::ls -> elt2;; 
      Characters 55-56:
    |_ :: [] -> _
                ^
Error: Syntax error
# let present l = match l with
  |[] -> []
  |_ :: [] -> []
  |elt::elt2::[] -> elt2;;
      Characters 16-82:
  ................match l with
    |[] -> []
    |_ :: [] -> []
    |elt::elt2::[] -> elt2..
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
_::_::_::_
val present : 'a list list -> 'a list = <fun>
# let present l = match l with
  |[] -> []
  |_ :: [] -> []
  |elt::elt2::ls -> elt::ls;;
      val present : 'a list -> 'a list = <fun>
# present [[4];[5];[6]];;
					     
- : int list list = [[4]; [6]]
#   let present l = match l with
  |[] -> []
  |elt::elt2::ls -> elt::ls;;
    Characters 27-79:
  ................match l with
    |[] -> []
    |elt::elt2::ls -> elt::ls..
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
_::[]
val present : 'a list -> 'a list = <fun>
# let present l = match l with
  |[] -> []
  |_ :: [] -> []
  |elt::elt2::ls -> elt::ls;;
      val present : 'a list -> 'a list = <fun>
# present [[3;4];[6;6];[5;5]];;
- : int list list = [[3; 4]; [5; 5]]
# let rec suppStatesDoublons listeListes = match listeListes with
  |[] -> []
  |state::[] -> listeListes
  |state1::state2::listeListesQueue -> if (comparerStates state1 state2 = true) then suppStatesDoublons (state2::listeListesQueue)
                                       else state1::suppStatesDoublons (state2::listeListesQueue);;
        val suppStatesDoublons : 'a list list -> 'a list list = <fun>
# suppStatesDoublons [[0;4];[4;0]];;
- : int list list = [[0; 4]; [4; 0]]
# suppStatesDoublons [[0;4];[4;0];[5];[5]];;
- : int list list = [[0; 4]; [4; 0]; [5]; [5]]
# suppStatesDoublons [[5];[5]];;
- : int list list = [[5]; [5]]
# let rec suppStatesDoublons listeListes = match listeListes with
  |[] -> []
  |state::[] -> listeListes
  |state1::listeListesQueue -> if (comparerStates state1 state2::listeListesQueue = true) then suppStatesDoublons listeListesQueue
                                       else state1::suppStatesDoublons listeListesQueue;;
        Characters 161-167:
    |state1::listeListesQueue -> if (comparerStates state1 state2::listeListesQueue = true) then suppStatesDoublons listeListesQueue
                                                           ^^^^^^
Error: Unbound value state2
Hint: Did you mean state1?
# List.ht [2;3;5];;
Characters 0-7:
  List.ht [2;3;5];;
  ^^^^^^^
Error: Unbound value List.ht
#  List.hd [2;3;5];;
- : int = 2
#   List.hd [[2];[3];[5]];;
- : int list = [2]
# let rec suppStatesDoublons listeListes = match listeListes with
  |[] -> []
  |state::[] -> listeListes
  |state1::listeListesQueue -> if (comparerStates state1 (List.hd listeListesQueue) = true) then suppStatesDoublons listeListesQueue
                                       else state1::suppStatesDoublons listeListesQueue;;
        val suppStatesDoublons : 'a list list -> 'a list list = <fun>
#  suppStatesDoublons [[0;4];[4;0];[5];[5]];;
- : int list list = [[0; 4]; [4; 0]; [5]; [5]]
# let suppStatesDoublons listeListes = match listeListes with
  |[] -> false
  |state::[] -> false
  |state1::listeListesQueue -> if (comparerStates state1 (List.hd listeListesQueue) = true) then true
                                       else false;;
        val suppStatesDoublons : 'a list list -> bool = <fun>
#   suppStatesDoublons [[0;4];[4;0];[5];[5]];;
- : bool = false
# comparerStates [5;3;4] [3;4;5];;
- : bool = false
# #trace comparerStates;;
comparerStates is now traced.
# comparerStates [5;3;4] [3;4;5];;
comparerStates <-- [<poly>; <poly>; <poly>]
comparerStates --> <fun>
comparerStates* <-- [<poly>; <poly>; <poly>]
comparerStates <-- [<poly>; <poly>]
comparerStates --> <fun>
comparerStates* <-- [<poly>; <poly>; <poly>]
comparerStates* --> false
comparerStates* --> false
- : bool = false
# comparerStates [5] [5;5];;
comparerStates <-- [<poly>]
comparerStates --> <fun>
comparerStates* <-- [<poly>; <poly>]
comparerStates* --> false
- : bool = false
# comparerStates [5;5] [5;6];;
comparerStates <-- [<poly>; <poly>]
comparerStates --> <fun>
comparerStates* <-- [<poly>; <poly>]
comparerStates <-- [<poly>]
comparerStates --> <fun>
comparerStates* <-- [<poly>; <poly>]
comparerStates* --> false
comparerStates* --> false
- : bool = false
# comparerStates [5;5] [5;5];;
comparerStates <-- [<poly>; <poly>]
comparerStates --> <fun>
comparerStates* <-- [<poly>; <poly>]
comparerStates <-- [<poly>]
comparerStates --> <fun>
comparerStates* <-- [<poly>; <poly>]
comparerStates* --> false
comparerStates* --> false
- : bool = false
# comparerStates [5] [5];;
comparerStates <-- [<poly>]
comparerStates --> <fun>
comparerStates* <-- [<poly>]
comparerStates <-- []
comparerStates --> <fun>
comparerStates* <-- [<poly>]
comparerStates* --> false
comparerStates* --> false
- : bool = false
# let rec comparerStates l1 l2 =
  if (nbrStates l1 = nbrStates l2)
  then match l1, l2 with
       |[], [] -> true
       |[], _ -> true
       |_, [] -> false
       |e1::l1Queue, _ -> if (estPresent e1 l2 = true) then true
                          else false
  else false;;
                val comparerStates : 'a list -> 'a list -> bool = <fun>
# comparerStates [5] [5;5];;
- : bool = false
# let rec comparerStates l1 l2 =
  if (nbrStates l1 = nbrStates l2)
  then match l1, l2 with
       |[], [] -> true
       |e1::l1Queue, _ -> if (estPresent e1 l2 = true) then true
                          else false
  else false;;
            Characters 73-215:
  .......match l1, l2 with
         |[], [] -> true
         |e1::l1Queue, _ -> if (estPresent e1 l2 = true) then true
                            else false
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
([], _::_)
val comparerStates : 'a list -> 'a list -> bool = <fun>
# comparerStates [5] [5;4];;
- : bool = false
# comparerStates [5;4] [5;4];;
- : bool = true
# comparerStates [4;5] [5;4];;
- : bool = true
# comparerStates [3;4] [5;6];;
- : bool = false
# let rec comparerStates l1 l2 =
  if (nbrStates l1 = nbrStates l2)
  then match l1, l2 with
       |[], [] -> true
       |[], _ -> true
       |e1::l1Queue, _ -> if (estPresent e1 l2 = true) then comparerStates l1Queue l2
                          else false
  else false;;
              val comparerStates : 'a list -> 'a list -> bool = <fun>
# comparerStates [5;4] [4;5];;
- : bool = false
# comparerStates [5;4] [5;4];;
- : bool = false
# comparerStates []let rec comparerStates l1 l2 =
  if (nbrStates l1 = nbrStates l2)
  then match l1, l2 with
       |[], [] -> true
       |[], l2 -> true
       |e1::l1Queue, l2 -> if (estPresent e1 l2 = true) then comparerStates l1Queue l2
                          else false
  else false;;
              val comparerStates : 'a list -> 'a list -> bool = <fun>
# comparerStates [5;4] [5;4];;
- : bool = false
# let rec comparerStates l1 l2 =
  if (nbrStates l1 = nbrStates l2)
  then match l1, l2 with
       |[], [] -> true
       |[], _ -> true
       |e1::l1Queue, _ -> if (estPresent e1 l2 = true) then true
                          else false
  else false;;
              val comparerStates : 'a list -> 'a list -> bool = <fun>
# comparerStates [5] [5];;
- : bool = true
# comparerStates [5;4] [4;5];;
- : bool = true
# let rec comparerStates l1 l2 = match l1, l2 with
       |[], [] -> true
       |[], _ -> true
       |e1::l1Queue, _ -> if (estPresent e1 l2 = true) then comparerStates l1Queue l2
                          else false;;
        val comparerStates : 'a list -> 'a list -> bool = <fun>
# comparerStates [5;4] [4,5];;
Characters 22-25:
  comparerStates [5;4] [4,5];;
                        ^^^
Error: This expression has type 'a * 'b
       but an expression was expected of type int
# comparerStates [5;4] [4;5];;
- : bool = true
# comparerStates [3;2;4;0;6] [6;0;3;5;2];;
- : bool = false
# comparerStates [3;2;4;0;6] [6;0;3;4;2];;
- : bool = true
# let suppStatesDoublons listeListes = match listeListes with
  |[] -> false
  |state::[] -> false
  |state1::listeListesQueue -> if (comparerStates state1 (List.hd listeListesQueue) = true) then true
                                       else false;;
        val suppStatesDoublons : 'a list list -> bool = <fun>
# suppStatesDoublons [[5];[5]];;
- : bool = true
# let suppStatesDoublons listeListes = match listeListes with
  |[] -> []
  |state::[] -> listeListes
  |state1::listeListesQueue -> if (comparerStates state1 (List.hd listeListesQueue) = true) then suppStatesDoublons listeListesQueue
                                       else state1::suppStatesDoublons listeListesQueue;;
        Characters 197-232:
    |state1::listeListesQueue -> if (comparerStates state1 (List.hd listeListesQueue) = true) then suppStatesDoublons listeListesQueue
                                                                                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Error: This expression has type bool but an expression was expected of type
         'a list list
# let suppStatesDoublons listeListes = match listeListes with
  |[] -> []
  |state::[] -> listeListes
  |state1::listeListesQueue -> if (comparerStates state1 (List.hd listeListesQueue) = true) then suppStatesDoublons listeListesQueue
                               else state1::suppStatesDoublons listeListesQueue;;
        Characters 197-232:
    |state1::listeListesQueue -> if (comparerStates state1 (List.hd listeListesQueue) = true) then suppStatesDoublons listeListesQueue
                                                                                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Error: This expression has type bool but an expression was expected of type
         'a list list
# let rec suppStatesDoublons listeListes = match listeListes with
  |[] -> []
  |state::[] -> listeListes
  |state1::listeListesQueue -> if (comparerStates state1 (List.hd listeListesQueue) = true) then suppStatesDoublons listeListesQueue
                               else state1::suppStatesDoublons listeListesQueue;;
        val suppStatesDoublons : 'a list list -> 'a list list = <fun>
# suppStatesDoublons [[5];[5]];;
- : int list list = [[5]]
# suppStatesDoublons [[5;4];[4;5]];;
- : int list list = [[4; 5]]
# suppStatesDoublons [[5;4];[5];[4;5];[5]];;
- : int list list = [[5; 4]; [4; 5]; [5]]
# suppStatesDoublons [[5;4];[5];[4;5];[5]];;
- : int list list = [[5; 4]; [4; 5]; [5]]
# suppStatesDoublons [[5;4];[4;5];[5]];;
- : int list list = [[4; 5]; [5]]
# suppStatesDoublons [[5];[5;4];[4;5];[5]];;
- : int list list = [[4; 5]; [5]]
# suppStatesDoublons [[5;4];[5;4];[4;5];[5]];;
- : int list list = [[4; 5]; [5]]
# suppStatesDoublons [[5;4];[5];[4;5];[5]];;
- : int list list = [[5; 4]; [4; 5]; [5]]
# suppStatesDoublons [[5;4];[5];[4;5];[5]];;
- : int list list = [[5; 4]; [4; 5]; [5]]
# suppStatesDoublons [[5];[4];[5];[4]];;
- : int list list = [[5]; [4]; [5]; [4]]
# suppStatesDoublons [[5];[4];[5]];;
- : int list list = [[5]; [4]; [5]]
# let rec suppStatesDoublons listeListes = match listeListes with
  |[] -> []
  |state::[] -> listeListes
  |state1::listeListesQueue -> if (comparerStates state1 (List.hd listeListesQueue) = true) then suppStatesDoublons listeListesQueue
                               else state1::suppStatesDoublons listeListesQueue;;
        val suppStatesDoublons : 'a list list -> 'a list list = <fun>
# suppStatesDoublons [[4];[5];[4];[5]];;
- : int list list = [[4]; [5]; [4]; [5]]
# suppStatesDoublons [[4;5];[4;5];[5;4];[5]];;
- : int list list = [[5; 4]; [5]]
# suppStatesDoublons [[4;5];[5];[5;4];[5]];;
- : int list list = [[4; 5]; [5; 4]; [5]]
# suppStatesDoublons [[4];[5];[4];[5]];;
- : int list list = [[4]; [5]; [4]; [5]]
# let rec  stateEstPresent stateK listeListes = match listeListes with
  |[] -> false
  |state1::[] -> if (comparerStates state1 stateK = true) then true
             else false
  |state1::listeListesQueue -> if (comparerStates state1 stateK = true) then true
                                          else stateEstPresent stateK listeListesQueue;;
          val stateEstPresent : 'a list -> 'a list list -> bool = <fun>
# stateEstPresent [4] [[4];[5];[4];[5]];;
- : bool = true
# stateEstPresent [5] [[4];[5];[4];[5]];;
- : bool = true
# stateEstPresent [6] [[4];[5];[4];[5];[6]];;
- : bool = true
# stateEstPresent [3] [[4];[5];[4];[5];[6]];;
- : bool = false
# let rec suppStatesDoublons listeListes = match listeListes with
  |[] -> []
  |state::[] -> listeListes
  |state1::listeListesQueue -> if (stateEstPresent state1 listeListesQueue = true) then suppStatesDoublons listeListesQueue
                               else state1::suppStatesDoublons listeListesQueue;;
        val suppStatesDoublons : 'a list list -> 'a list list = <fun>
# suppStatesDoublons [[4];[5];[4];[5]];;
- : int list list = [[4]; [5]]
# suppStatesDoublons [[4;5;6];[5];[4];[5;6;4]];;
- : int list list = [[5]; [4]; [5; 6; 4]]
# suppStatesDoublons [[4;5;6];[5];[4];[5;6;4];[5];[4]];;
- : int list list = [[5]; [4]]
# suppStatesDoublons [[4;5;6];[5];[4];[5;6;4];[5];[4]];;
- : int list list = [[5]; [4]]
# suppStatesDoublons [[4;6];[5];[4];[5;6;4];[5];[4]];;
- : int list list = [[5]; [4]]
# suppStatesDoublons [[4;6];[5];[4];[5;6;4];[5];[4]];;
- : int list list = [[5]; [4]]
# suppStatesDoublons [[4;6];[5];[4];[5;6;4]];;
- : int list list = [[5]; [4]; [5; 6; 4]]
# let rec suppStatesDoublons listeListes = match listeListes with
  |[] -> []
  |state::[] -> listeListes
  |state1::listeListesQueue -> if (stateEstPresent state1 listeListesQueue = true) then suppStatesDoublons listeListesQueue
                               else state1::suppStatesDoublons listeListesQueue;;
        val suppStatesDoublons : 'a list list -> 'a list list = <fun>
# 